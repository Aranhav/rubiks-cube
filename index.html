<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Realistic 3D Rubik's Cube</title>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap');

        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            overflow: hidden;
            background: #000000;
            font-family: 'Inter', sans-serif;
            user-select: none;
            -webkit-user-select: none;
        }

        #canvas-container {
            width: 100vw;
            height: 100vh;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
        }

        /* Liquid Glass HUD Styling */
        .hud-panel {
            pointer-events: auto;
            position: relative;
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.1) 0%,
                rgba(255, 255, 255, 0.05) 50%,
                rgba(255, 255, 255, 0.02) 100%
            );
            backdrop-filter: blur(20px) saturate(180%);
            -webkit-backdrop-filter: blur(20px) saturate(180%);
            border: 1px solid rgba(255, 255, 255, 0.18);
            padding: 20px 28px;
            border-radius: 24px;
            color: #f0f0f0;
            margin: 20px;
            box-shadow:
                0 8px 32px rgba(0, 0, 0, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2),
                inset 0 -1px 0 rgba(0, 0, 0, 0.1);
            overflow: hidden;
        }

        /* Liquid glass shine effect */
        .hud-panel::before {
            content: '';
            position: absolute;
            top: 0;
            left: -50%;
            width: 200%;
            height: 100%;
            background: linear-gradient(
                90deg,
                transparent 0%,
                rgba(255, 255, 255, 0.03) 45%,
                rgba(255, 255, 255, 0.1) 50%,
                rgba(255, 255, 255, 0.03) 55%,
                transparent 100%
            );
            transform: skewX(-20deg);
            pointer-events: none;
        }

        .top-bar {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 20px;
        }

        .title-section {
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .controls-area {
            display: flex;
            gap: 8px;
            align-items: center;
            flex-wrap: wrap;
        }

        h1 {
            margin: 0;
            font-size: 1.35rem;
            font-weight: 600;
            color: white;
            letter-spacing: 0.3px;
            text-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        }

        .btn {
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.15) 0%,
                rgba(255, 255, 255, 0.05) 100%
            );
            border: 1px solid rgba(255, 255, 255, 0.2);
            color: white;
            padding: 10px 18px;
            border-radius: 12px;
            font-size: 0.85rem;
            cursor: pointer;
            font-weight: 500;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            font-family: inherit;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            box-shadow:
                0 4px 15px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
            text-shadow: 0 1px 2px rgba(0, 0, 0, 0.2);
        }

        .btn:hover {
            background: linear-gradient(
                135deg,
                rgba(255, 255, 255, 0.25) 0%,
                rgba(255, 255, 255, 0.1) 100%
            );
            transform: translateY(-2px);
            box-shadow:
                0 6px 20px rgba(0, 0, 0, 0.3),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
            border-color: rgba(255, 255, 255, 0.3);
        }

        .btn:active {
            transform: translateY(0);
            box-shadow:
                0 2px 10px rgba(0, 0, 0, 0.2),
                inset 0 1px 0 rgba(255, 255, 255, 0.1);
        }

        .btn.primary {
            background: linear-gradient(
                135deg,
                rgba(37, 99, 235, 0.9) 0%,
                rgba(29, 78, 216, 0.9) 100%
            );
            border-color: rgba(59, 130, 246, 0.5);
            box-shadow:
                0 4px 15px rgba(37, 99, 235, 0.4),
                inset 0 1px 0 rgba(255, 255, 255, 0.2);
        }

        .btn.primary:hover {
            background: linear-gradient(
                135deg,
                rgba(59, 130, 246, 0.95) 0%,
                rgba(37, 99, 235, 0.95) 100%
            );
            box-shadow:
                0 6px 25px rgba(37, 99, 235, 0.5),
                inset 0 1px 0 rgba(255, 255, 255, 0.3);
        }

        .btn.reset {
            background: linear-gradient(
                135deg,
                rgba(239, 68, 68, 0.2) 0%,
                rgba(220, 38, 38, 0.1) 100%
            );
            border-color: rgba(239, 68, 68, 0.3);
        }

        .btn.reset:hover {
            background: linear-gradient(
                135deg,
                rgba(239, 68, 68, 0.4) 0%,
                rgba(220, 38, 38, 0.3) 100%
            );
            border-color: rgba(239, 68, 68, 0.5);
        }

        select {
            background: linear-gradient(
                135deg,
                rgba(0, 0, 0, 0.3) 0%,
                rgba(0, 0, 0, 0.2) 100%
            );
            color: white;
            border: 1px solid rgba(255, 255, 255, 0.2);
            padding: 10px 14px;
            border-radius: 12px;
            font-family: inherit;
            font-size: 0.85rem;
            font-weight: 500;
            outline: none;
            cursor: pointer;
            backdrop-filter: blur(10px);
            -webkit-backdrop-filter: blur(10px);
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.2);
        }

        select:hover {
            border-color: rgba(255, 255, 255, 0.35);
            background: linear-gradient(
                135deg,
                rgba(0, 0, 0, 0.4) 0%,
                rgba(0, 0, 0, 0.3) 100%
            );
        }

        select:focus {
            border-color: rgba(59, 130, 246, 0.5);
        }

        .stats {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.6);
            font-weight: 400;
        }

        #hint-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 3rem;
            font-weight: 800;
            text-shadow: 0 4px 20px rgba(0,0,0,0.6);
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.3s, transform 0.3s;
            z-index: 10;
        }

        .bottom-hint {
            align-self: center;
            margin-bottom: 30px;
            text-align: center;
            padding: 12px 24px !important;
        }

        .bottom-hint span {
            font-size: 0.8rem;
            color: rgba(255, 255, 255, 0.5);
            font-weight: 400;
            letter-spacing: 0.5px;
        }

        /* Mobile Responsive Design */
        @media (max-width: 768px) {
            .hud-panel {
                margin: 12px;
                padding: 16px 20px;
                border-radius: 20px;
            }

            .top-bar {
                flex-direction: column;
                align-items: stretch;
                gap: 16px;
            }

            .title-section {
                text-align: center;
                padding-bottom: 12px;
                border-bottom: 1px solid rgba(255, 255, 255, 0.1);
            }

            h1 {
                font-size: 1.15rem;
            }

            .controls-area {
                justify-content: center;
                gap: 6px;
            }

            .btn {
                padding: 8px 12px;
                font-size: 0.75rem;
                border-radius: 10px;
            }

            select {
                padding: 8px 10px;
                font-size: 0.75rem;
                border-radius: 10px;
            }

            .stats {
                font-size: 0.7rem;
            }

            .bottom-hint {
                margin-bottom: 20px;
                padding: 10px 16px !important;
            }

            .bottom-hint span {
                font-size: 0.7rem;
            }
        }

        @media (max-width: 400px) {
            .hud-panel {
                margin: 8px;
                padding: 12px 16px;
            }

            h1 {
                font-size: 1rem;
            }

            .btn {
                padding: 7px 10px;
                font-size: 0.7rem;
            }

            select {
                padding: 7px 8px;
                font-size: 0.7rem;
            }

            .controls-area {
                gap: 4px;
            }
        }
    </style>
    <!-- Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
</head>
<body>

    <div id="canvas-container"></div>

    <div id="ui-layer">
        <div class="top-bar hud-panel">
            <div class="title-section">
                <h1>Realistic 3D Rubik's Cube</h1>
                <div class="stats" id="move-counter">Moves: 0</div>
            </div>
            <div class="controls-area">
                <select id="cube-size">
                    <option value="2">2 x 2</option>
                    <option value="3" selected>3 x 3</option>
                    <option value="4">4 x 4</option>
                    <option value="5">5 x 5</option>
                </select>
                <button class="btn" id="btn-scramble">Scramble</button>
                <button class="btn primary" id="btn-solve">Auto-Solve</button>
                <button class="btn reset" id="btn-reset">Reset</button>
            </div>
        </div>

        <div class="hud-panel bottom-hint">
            <span>Drag to Rotate â€¢ Scroll/Pinch to Zoom</span>
        </div>
    </div>

    <div id="hint-text">SOLVED!</div>

    <script>
        // --- CONFIGURATION ---
        const CONFIG = {
            // Vibrant Rubik's Colors
            colors: {
                U: 0xFFFFFF, // White
                D: 0xFFE500, // Vibrant Yellow
                F: 0x00FF41, // Vibrant Green
                B: 0x0080FF, // Vibrant Blue
                R: 0xFF0040, // Vibrant Red
                L: 0xFF8C00, // Vibrant Orange
                Core: 0x0a0a0a // Dark Black Plastic
            },
            animationSpeed: 0.5,
            cubeSpacing: 0.01
        };

        // --- GLOBAL STATE ---
        let scene, camera, renderer;
        let cubeGroup;
        let allCubies = [];
        let dimension = 3;
        let isDragging = false;
        let isRotatingLayer = false;
        let startMouse = new THREE.Vector2();
        let moveHistory = [];
        let isAnimating = false;

        // Action Control
        let actionTimeout = null; // To cancel scrambles/solves on reset

        // Raycasting
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();

        // Interaction Logic
        let intersectedCubie = null;
        let intersectNormal = null;
        let activeGroup = null;
        let activeAxis = null;
        let currentRotationAngle = 0;

        // Adjusted sensitivity for 1:1 feel
        let rotationPixelToAngleRatio = 0.01;

        function init() {
            const container = document.getElementById('canvas-container');

            scene = new THREE.Scene();

            camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 100);
            camera.position.set(5, 4, 7);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            renderer.physicallyCorrectLights = true;
            renderer.shadowMap.enabled = true;
            renderer.shadowMap.type = THREE.PCFSoftShadowMap;
            renderer.outputEncoding = THREE.sRGBEncoding;
            renderer.toneMapping = THREE.ReinhardToneMapping;
            renderer.toneMappingExposure = 2.5;
            container.appendChild(renderer.domElement);

            // --- Studio Lighting ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const mainLight = new THREE.DirectionalLight(0xffffff, 1.5);
            mainLight.position.set(10, 20, 10);
            mainLight.castShadow = true;
            mainLight.shadow.mapSize.width = 2048;
            mainLight.shadow.mapSize.height = 2048;
            scene.add(mainLight);

            const fillLight = new THREE.DirectionalLight(0xeef4ff, 0.8);
            fillLight.position.set(-10, 5, -10);
            scene.add(fillLight);

            const rimLight = new THREE.SpotLight(0xffffff, 1.0);
            rimLight.position.set(0, 10, 0);
            scene.add(rimLight);

            createCube(dimension);

            // Listeners
            window.addEventListener('resize', onWindowResize, false);
            const canvas = renderer.domElement;

            // Mouse/Touch
            canvas.addEventListener('mousedown', onInputStart);
            canvas.addEventListener('mousemove', onInputMove);
            window.addEventListener('mouseup', onInputEnd);
            canvas.addEventListener('touchstart', (e) => {
                if(e.touches.length === 1) { e.preventDefault(); onInputStart(e.touches[0]); }
            }, {passive: false});
            canvas.addEventListener('touchmove', (e) => {
                if(e.touches.length === 1) { e.preventDefault(); onInputMove(e.touches[0]); }
            }, {passive: false});
            window.addEventListener('touchend', onInputEnd);

            // Zoom (Wheel)
            canvas.addEventListener('wheel', onWheel, { passive: false });

            // UI
            document.getElementById('cube-size').addEventListener('change', (e) => {
                dimension = parseInt(e.target.value);
                createCube(dimension);
            });
            document.getElementById('btn-scramble').addEventListener('click', scrambleCube);
            document.getElementById('btn-reset').addEventListener('click', resetCube);
            document.getElementById('btn-solve').addEventListener('click', solveCube);

            animate();
        }

        // --- ZOOM Logic ---
        function onWheel(event) {
            event.preventDefault();

            // Calculate current distance
            const offset = camera.position.clone().sub(scene.position);
            let dist = offset.length();

            // Zoom sensitivity
            const zoomSpeed = 0.001;
            dist += event.deltaY * zoomSpeed * dist;

            // Clamp zoom
            dist = Math.max(2, Math.min(dist, 20));

            // Re-position camera maintaining direction
            offset.normalize().multiplyScalar(dist);
            camera.position.copy(scene.position).add(offset);
        }

        // --- GEOMETRY: Realistic Plastic Cube ---
        function createCubeGeometry() {
            const shape = new THREE.Shape();
            const size = 0.96;
            const r = 0.08;
            const w = size; const h = size;
            const x = -w/2; const y = -h/2;

            shape.moveTo(x + r, y);
            shape.lineTo(x + w - r, y);
            shape.quadraticCurveTo(x + w, y, x + w, y + r);
            shape.lineTo(x + w, y + h - r);
            shape.quadraticCurveTo(x + w, y + h, x + w - r, y + h);
            shape.lineTo(x + r, y + h);
            shape.quadraticCurveTo(x, y + h, x, y + h - r);
            shape.lineTo(x, y + r);
            shape.quadraticCurveTo(x, y, x + r, y);

            const extrudeSettings = {
                steps: 1,
                depth: size - (0.01 * 2),
                bevelEnabled: true,
                bevelThickness: 0.02,
                bevelSize: 0.02,
                bevelSegments: 3
            };

            const geometry = new THREE.ExtrudeGeometry(shape, extrudeSettings);
            geometry.center();
            return geometry;
        }

        function createCube(n) {
            // 1. Stop any running animations/logic
            if (actionTimeout) clearTimeout(actionTimeout);
            isAnimating = false;
            if(activeGroup) {
                scene.remove(activeGroup);
                activeGroup = null;
            }
            activeAxis = null;

            if(cubeGroup) scene.remove(cubeGroup);

            cubeGroup = new THREE.Group();
            allCubies = [];
            moveHistory = []; // Reset history
            updateUI();

            const offset = (n - 1) / 2;
            const geometry = createCubeGeometry();

            const stickerShape = new THREE.Shape();
            const sSize = 0.84;
            const sR = 0.06;
            const sx = -sSize/2; const sy = -sSize/2;
            stickerShape.moveTo(sx + sR, sy);
            stickerShape.lineTo(sx + sSize - sR, sy);
            stickerShape.quadraticCurveTo(sx + sSize, sy, sx + sSize, sy + sR);
            stickerShape.lineTo(sx + sSize, sy + sSize - sR);
            stickerShape.quadraticCurveTo(sx + sSize, sy + sSize, sx + sSize - sR, sy + sSize);
            stickerShape.lineTo(sx + sR, sy + sSize);
            stickerShape.quadraticCurveTo(sx, sy + sSize, sx, sy + sSize - sR);
            stickerShape.lineTo(sx, sy + sR);
            stickerShape.quadraticCurveTo(sx, sy, sx + sR, sy);

            const stickerGeo = new THREE.ShapeGeometry(stickerShape);

            const plasticMat = new THREE.MeshStandardMaterial({
                color: CONFIG.colors.Core,
                roughness: 0.5,
                metalness: 0.0,
            });

            for(let x = 0; x < n; x++) {
                for(let y = 0; y < n; y++) {
                    for(let z = 0; z < n; z++) {
                        const group = new THREE.Group();
                        group.position.set(x - offset, y - offset, z - offset);

                        const body = new THREE.Mesh(geometry, plasticMat);
                        body.castShadow = true;
                        body.receiveShadow = true;
                        group.add(body);

                        const addSticker = (color, rotX, rotY, posX, posY, posZ) => {
                            const mat = new THREE.MeshStandardMaterial({
                                color: color,
                                roughness: 0.2,
                                metalness: 0.0,
                                polygonOffset: true,
                                polygonOffsetFactor: -2 // Increased push to prevent Z-fighting
                            });
                            const mesh = new THREE.Mesh(stickerGeo, mat);
                            mesh.rotation.set(rotX, rotY, 0);
                            mesh.position.set(posX, posY, posZ);
                            group.add(mesh);
                        };

                        // Increased distance slightly to ensure visibility
                        const dist = 0.51;

                        if (x === n-1) addSticker(CONFIG.colors.R, 0, Math.PI/2, dist, 0, 0);
                        if (x === 0)   addSticker(CONFIG.colors.L, 0, -Math.PI/2, -dist, 0, 0);
                        if (y === n-1) addSticker(CONFIG.colors.U, -Math.PI/2, 0, 0, dist, 0);
                        if (y === 0)   addSticker(CONFIG.colors.D, Math.PI/2, 0, 0, -dist, 0);
                        if (z === n-1) addSticker(CONFIG.colors.F, 0, 0, 0, 0, dist);
                        if (z === 0)   addSticker(CONFIG.colors.B, 0, Math.PI, 0, 0, -dist);

                        body.userData = { parentGroup: group };
                        group.userData = {
                            x: x - offset,
                            y: y - offset,
                            z: z - offset
                        };

                        cubeGroup.add(group);
                        allCubies.push(group);
                    }
                }
            }
            scene.add(cubeGroup);
            camera.position.setLength(n * 2.5 + 4);
            showFeedback("");
        }

        // --- INTERACTION LOGIC ---

        function onInputStart(event) {
            if (isAnimating) return;

            mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
            mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

            raycaster.setFromCamera(mouse, camera);
            const meshes = [];
            allCubies.forEach(g => meshes.push(g.children[0]));

            const intersects = raycaster.intersectObjects(meshes);

            if (intersects.length > 0) {
                isDragging = true;
                isRotatingLayer = false;
                intersectedCubie = intersects[0].object.userData.parentGroup;
                intersectNormal = intersects[0].face.normal.clone();
                intersectNormal.transformDirection(intersects[0].object.matrixWorld).round();
                startMouse.set(event.clientX, event.clientY);
            } else {
                isDragging = true;
                intersectedCubie = null;
                startMouse.set(event.clientX, event.clientY);
            }
        }

        function onInputMove(event) {
            if (!isDragging) return;

            const deltaX = event.clientX - startMouse.x;
            const deltaY = event.clientY - startMouse.y;

            if (intersectedCubie) {
                if (!isRotatingLayer) {
                    if (Math.abs(deltaX) > 8 || Math.abs(deltaY) > 8) {
                        isRotatingLayer = true;
                        initiateLayerRotation(deltaX, deltaY);
                    }
                } else {
                    updateLayerRotation(deltaX, deltaY);
                }
            } else {
                // Orbit Logic
                const rotSpeed = 0.003;
                const offset = camera.position.clone().sub(scene.position);
                let theta = Math.atan2(offset.x, offset.z);
                let phi = Math.acos(offset.y / offset.length());

                const dx = event.movementX !== undefined ? event.movementX : (event.clientX - startMouse.x);
                const dy = event.movementY !== undefined ? event.movementY : (event.clientY - startMouse.y);

                theta -= dx * rotSpeed;
                phi -= dy * rotSpeed;
                phi = Math.max(0.1, Math.min(Math.PI - 0.1, phi));
                const radius = offset.length();
                camera.position.x = radius * Math.sin(phi) * Math.sin(theta);
                camera.position.y = radius * Math.cos(phi);
                camera.position.z = radius * Math.sin(phi) * Math.cos(theta);
                camera.lookAt(scene.position);

                startMouse.set(event.clientX, event.clientY);
            }
        }

        function onInputEnd() {
            if (isRotatingLayer && activeGroup) {
                snapLayer();
            }
            isDragging = false;
            isRotatingLayer = false;
            intersectedCubie = null;
        }

        // --- ROTATION MATH ---

        function initiateLayerRotation(dx, dy) {
            const potentialAxes = [];
            if (Math.abs(intersectNormal.x) < 0.1) potentialAxes.push(new THREE.Vector3(1,0,0));
            if (Math.abs(intersectNormal.y) < 0.1) potentialAxes.push(new THREE.Vector3(0,1,0));
            if (Math.abs(intersectNormal.z) < 0.1) potentialAxes.push(new THREE.Vector3(0,0,1));

            let matchedAxis = null;
            let maxDot = -1;

            const mouseVec = new THREE.Vector2(dx, -dy).normalize();

            potentialAxes.forEach(axis => {
                const p1 = intersectedCubie.position.clone().project(camera);
                const p2 = intersectedCubie.position.clone().add(axis).project(camera);
                const screenVec = new THREE.Vector2(p2.x - p1.x, p2.y - p1.y).normalize();

                const dot = Math.abs(screenVec.dot(mouseVec));
                if (dot > maxDot) {
                    maxDot = dot;
                    matchedAxis = axis;
                }
            });

            activeAxis = potentialAxes.find(a => !a.equals(matchedAxis));
            if(!activeAxis) activeAxis = potentialAxes[0];

            activeGroup = new THREE.Group();
            scene.add(activeGroup);
            activeGroup.rotation.set(0,0,0);

            currentRotationAngle = 0;

            const epsilon = 0.1;
            const pos = intersectedCubie.position;

            const cubiesToRotate = allCubies.filter(c => {
                if(Math.abs(activeAxis.x) > 0.5) return Math.abs(c.position.x - pos.x) < epsilon;
                if(Math.abs(activeAxis.y) > 0.5) return Math.abs(c.position.y - pos.y) < epsilon;
                if(Math.abs(activeAxis.z) > 0.5) return Math.abs(c.position.z - pos.z) < epsilon;
            });

            cubiesToRotate.forEach(c => {
                activeGroup.attach(c);
            });
        }

        function updateLayerRotation(dx, dy) {
            if(!activeGroup || !activeAxis) return;

            const hitVec = intersectedCubie.position.clone();
            const moveDir3D = new THREE.Vector3().crossVectors(activeAxis, hitVec).normalize();

            const p1 = intersectedCubie.position.clone().project(camera);
            const p2 = intersectedCubie.position.clone().add(moveDir3D).project(camera);
            const screenDir = new THREE.Vector2(p2.x - p1.x, p2.y - p1.y);

            const mouseVec = new THREE.Vector2(dx, -dy);
            const projectedDist = mouseVec.dot(screenDir.normalize());

            currentRotationAngle = projectedDist * rotationPixelToAngleRatio;

            activeGroup.rotation.set(0,0,0);
            activeGroup.rotateOnWorldAxis(activeAxis, currentRotationAngle);
        }

        function snapLayer() {
            const segment = Math.PI / 2;
            const snappedAngle = Math.round(currentRotationAngle / segment) * segment;

            isAnimating = true;
            const startRot = currentRotationAngle;
            const endRot = snappedAngle;

            let progress = 0;
            const duration = 300;
            const startTime = performance.now();

            function animateSnap(time) {
                const elapsed = time - startTime;
                progress = Math.min(elapsed / duration, 1);
                const ease = 1 - (1 - progress) * (1 - progress);

                const cur = startRot + (endRot - startRot) * ease;
                activeGroup.rotation.set(0,0,0);
                activeGroup.rotateOnWorldAxis(activeAxis, cur);

                if (progress < 1) {
                    requestAnimationFrame(animateSnap);
                } else {
                    finishRotation(snappedAngle);
                }
            }
            requestAnimationFrame(animateSnap);
        }

        function finishRotation(angle) {
            isAnimating = false;
            currentRotationAngle = 0;

            const children = [...activeGroup.children];
            children.forEach(c => {
                scene.attach(c);
                c.position.x = Math.round(c.position.x);
                c.position.y = Math.round(c.position.y);
                c.position.z = Math.round(c.position.z);
                c.rotation.x = Math.round(c.rotation.x / (Math.PI/2)) * (Math.PI/2);
                c.rotation.y = Math.round(c.rotation.y / (Math.PI/2)) * (Math.PI/2);
                c.rotation.z = Math.round(c.rotation.z / (Math.PI/2)) * (Math.PI/2);
                c.updateMatrixWorld();
            });

            scene.remove(activeGroup);
            activeGroup = null;

            if (Math.abs(angle) > 0.1) {
                const turns = Math.round(angle / (Math.PI/2));
                let sliceVal = 0;
                if(activeAxis.x) sliceVal = children[0].position.x;
                if(activeAxis.y) sliceVal = children[0].position.y;
                if(activeAxis.z) sliceVal = children[0].position.z;

                moveHistory.push({
                    axis: activeAxis.clone(),
                    slice: Math.round(sliceVal),
                    turns: turns
                });
                updateUI();
            }
            activeAxis = null;
        }

        // --- SOLVER ---

        function performMove(axis, slice, turns, animate = true) {
            if (isAnimating) return;
            isAnimating = true;

            activeAxis = axis;

            activeGroup = new THREE.Group();
            scene.add(activeGroup);

            const epsilon = 0.1;
            const cubiesToRotate = allCubies.filter(c => {
                if(Math.abs(axis.x) > 0.5) return Math.abs(c.position.x - slice) < epsilon;
                if(Math.abs(axis.y) > 0.5) return Math.abs(c.position.y - slice) < epsilon;
                if(Math.abs(axis.z) > 0.5) return Math.abs(c.position.z - slice) < epsilon;
            });

            cubiesToRotate.forEach(c => activeGroup.attach(c));

            const targetAngle = turns * (Math.PI / 2);

            if(!animate) {
                activeGroup.rotateOnWorldAxis(axis, targetAngle);
                finishRotation(targetAngle);
                return;
            }

            let progress = 0;
            const duration = CONFIG.animationSpeed * 1000;
            const startTime = performance.now();

            function loop(time) {
                const elapsed = time - startTime;
                progress = Math.min(elapsed / duration, 1);
                const ease = 1 - Math.pow(1 - progress, 4);

                activeGroup.rotation.set(0,0,0);
                activeGroup.rotateOnWorldAxis(axis, targetAngle * ease);

                if(progress < 1) {
                    requestAnimationFrame(loop);
                } else {
                    finishRotation(targetAngle);
                }
            }
            requestAnimationFrame(loop);
        }

        function scrambleCube() {
            if(isAnimating) return;

            // Clear existing actions
            if(actionTimeout) clearTimeout(actionTimeout);

            const moves = 20;
            const savedSpeed = CONFIG.animationSpeed;
            CONFIG.animationSpeed = 0.1;

            let i = 0;
            function next() {
                if (i >= moves) {
                    CONFIG.animationSpeed = savedSpeed;
                    updateUI();
                    return;
                }

                const axes = [new THREE.Vector3(1,0,0), new THREE.Vector3(0,1,0), new THREE.Vector3(0,0,1)];
                const axis = axes[Math.floor(Math.random()*3)];
                const maxOff = (dimension - 1) / 2;
                const sliceIndex = Math.floor(Math.random() * dimension);
                const slice = -maxOff + sliceIndex;
                const turns = Math.random() > 0.5 ? 1 : -1;

                performMove(axis, slice, turns);

                // Store ID to allow cancellation
                actionTimeout = setTimeout(next, 120);
                i++;
            }
            next();
        }

        function solveCube() {
            if (moveHistory.length === 0 || isAnimating) return;

            // Clear existing actions
            if(actionTimeout) clearTimeout(actionTimeout);

            const lastMove = moveHistory.pop();
            const inverseTurns = -lastMove.turns;

            performMove(lastMove.axis, lastMove.slice, inverseTurns);

            const duration = CONFIG.animationSpeed * 1000 + 50;
            actionTimeout = setTimeout(() => {
                moveHistory.pop();
                updateUI();

                if(moveHistory.length > 0) {
                    solveCube();
                } else {
                    showFeedback("SOLVED!");
                }
            }, duration);
        }

        function resetCube() {
            // If no moves to reverse or already animating, just recreate
            if (moveHistory.length === 0 || isAnimating) {
                // Stop any ongoing actions
                if (actionTimeout) {
                    clearTimeout(actionTimeout);
                    actionTimeout = null;
                }
                isAnimating = false;
                isDragging = false;
                isRotatingLayer = false;

                if (activeGroup) {
                    const children = [...activeGroup.children];
                    children.forEach(c => scene.attach(c));
                    scene.remove(activeGroup);
                    activeGroup = null;
                }
                activeAxis = null;

                createCube(dimension);
                showFeedback("RESET");
                return;
            }

            // Clear existing actions
            if (actionTimeout) clearTimeout(actionTimeout);

            // Save original speed and set fast reset speed
            const savedSpeed = CONFIG.animationSpeed;
            CONFIG.animationSpeed = 0.05; // Very fast

            function resetNext() {
                if (moveHistory.length === 0) {
                    CONFIG.animationSpeed = savedSpeed;
                    updateUI();
                    showFeedback("RESET");
                    return;
                }

                const lastMove = moveHistory.pop();
                const inverseTurns = -lastMove.turns;

                performMove(lastMove.axis, lastMove.slice, inverseTurns);

                // Faster interval for reset
                actionTimeout = setTimeout(() => {
                    moveHistory.pop(); // Remove the inverse move that was added
                    updateUI();
                    resetNext();
                }, 70); // Very fast timing
            }

            resetNext();
        }

        function updateUI() {
            document.getElementById('move-counter').innerText = `Moves: ${moveHistory.length}`;
        }

        function showFeedback(text) {
            const el = document.getElementById('hint-text');
            el.innerText = text;
            el.style.opacity = 1;
            el.style.transform = "translate(-50%, -50%) scale(1)";
            setTimeout(() => {
                el.style.opacity = 0;
                el.style.transform = "translate(-50%, -50%) scale(0.8)";
            }, 2000);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            renderer.render(scene, camera);
        }

        init();

    </script>
</body>
</html>
